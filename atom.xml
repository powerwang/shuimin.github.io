<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>架构师</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.springwork.cn/"/>
  <updated>2017-11-26T13:48:39.000Z</updated>
  <id>http://www.springwork.cn/</id>
  
  <author>
    <name>王水民(Burton)</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>技术好文</title>
    <link href="http://www.springwork.cn/%E5%A5%BD%E6%96%87%E6%94%B6%E8%97%8F%E5%88%97%E8%A1%A8.html"/>
    <id>http://www.springwork.cn/好文收藏列表.html</id>
    <published>2017-11-26T13:25:06.000Z</published>
    <updated>2017-11-26T13:48:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>#技术好文 </p>
<h2 id="一、流控"><a href="#一、流控" class="headerlink" title="一、流控"></a>一、流控</h2><ol>
<li><a href="https://en.wikipedia.org/wiki/Token_bucket" target="_blank" rel="external">Token bucket</a></li>
<li><a href="http://www.54tianzhisheng.cn/2017/11/18/flow-control/" target="_blank" rel="external">基于分布式环境下限流系统的设计</a></li>
<li><a href="https://www.zybuluo.com/kay2/note/949160" target="_blank" rel="external">基于Redis的限流系统的设计</a></li>
<li><a href="http://jinnianshilongnian.iteye.com/blog/2305117" target="_blank" rel="external">聊聊高并发系统之限流特技</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/20872901" target="_blank" rel="external">API 调用次数限制实现</a></li>
<li><a href="https://mp.weixin.qq.com/s/BcF5_nNPFbWLDvbuAWr6kA" target="_blank" rel="external">基于Kafka/Storm的实时流量控制系统</a></li>
</ol>
<h2 id="二、网关设计"><a href="#二、网关设计" class="headerlink" title="二、网关设计"></a>二、网关设计</h2><ol>
<li><a href="https://mp.weixin.qq.com/s/57sno2kfSrVWVMGFXyASjQ" target="_blank" rel="external">谈谈基于 OpenResty 的接口网关设计</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;#技术好文 &lt;/p&gt;
&lt;h2 id=&quot;一、流控&quot;&gt;&lt;a href=&quot;#一、流控&quot; class=&quot;headerlink&quot; title=&quot;一、流控&quot;&gt;&lt;/a&gt;一、流控&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Tok
    
    </summary>
    
      <category term="架构师晋级" scheme="http://www.springwork.cn/categories/%E6%9E%B6%E6%9E%84%E5%B8%88%E6%99%8B%E7%BA%A7/"/>
    
    
      <category term="java学习脑图" scheme="http://www.springwork.cn/tags/java%E5%AD%A6%E4%B9%A0%E8%84%91%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>java学习脑图(转)</title>
    <link href="http://www.springwork.cn/Java%E9%AB%98%E7%BA%A7%E6%9E%B6%E6%9E%84%E5%B8%88%E7%B3%BB%E7%BB%9F%E8%BF%9B%E9%98%B6%E7%BA%BF%E8%B7%AF.html"/>
    <id>http://www.springwork.cn/Java高级架构师系统进阶线路.html</id>
    <published>2017-11-26T12:10:03.000Z</published>
    <updated>2017-11-26T13:48:36.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li>工程化专题（团队大于3个人之后，你需要去考虑团队合作，科学管理）<br><img src="../images/java_learm/15116988518629.jpg" alt="">  <a id="more"></a></li>
<li><p>源码分析专题（好的程序员，一行代码一个设计就能看出来,源码分析带你品味代码，感受架构）<br><img src="../images/java_learm/15116985418293.jpg" alt=""></p>
</li>
<li><p>高性能及分布式专题（跟上技术节奏，扩宽技术视野,程序员要往上提升，要有自己的技术工具箱和技术认知。<br><img src="../images/java_learm/15116986576845.jpg" alt=""></p>
</li>
<li>技术架构专题（真实案例分享，带你领略大型项目风采）<br><img src="../images/java_learm/15116989256542.jpg" alt=""></li>
<li>性能调优（追求高效、科学调优，不靠碰运气）<br><img src="../images/java_learm/15116989581760.jpg" alt=""><br><img src="../images/java_learm/15116990112546.jpg" alt=""><br><img src="../images/java_learm/15116990290133.jpg" alt=""><br><img src="../images/java_learm/15116990460505.jpg" alt=""><br><img src="../images/java_learm/15116990752613.jpg" alt=""><br><img src="../images/java_learm/15116990946798.jpg" alt=""><br><img src="../images/java_learm/15116991167828.jpg" alt=""><br><img src="../images/java_learm/15116991609396.jpg" alt=""><br><img src="../images/java_learm/15116991958287.jpg" alt=""><br><img src="../images/java_learm/15116992135411.jpg" alt=""><br><img src="../images/java_learm/15116994510741.jpg" alt=""><br><img src="../images/java_learm/15116994633358.jpg" alt=""><br><img src="../images/java_learm/15116994768788.jpg" alt=""><br><img src="../images/java_learm/15116994961177.jpg" alt=""><br><img src="../images/java_learm/15116995093805.jpg" alt=""><br><img src="../images/java_learm/15116995228647.jpg" alt=""><br><img src="../images/java_learm/15116995359874.jpg" alt=""><br><img src="../images/java_learm/15116995486952.jpg" alt=""><br><img src="../images/java_learm/15116995609603.jpg" alt=""><br><img src="../images/java_learm/15116995754080.jpg" alt=""><br><img src="../images/java_learm/15116995894395.jpg" alt=""><br><img src="../images/java_learm/15116996027051.jpg" alt=""><br><img src="../images/java_learm/15116996184299.jpg" alt=""><br><img src="../images/java_learm/15116996312898.jpg" alt=""><br><img src="../images/java_learm/15116996434780.jpg" alt=""><br><img src="../images/java_learm/15116996570600.jpg" alt=""><br><img src="../images/java_learm/15116996753259.jpg" alt=""><br><img src="../images/java_learm/15116996890319.jpg" alt=""><br><img src="../images/java_learm/15116997535358.jpg" alt=""><br><img src="../images/java_learm/15116997685502.jpg" alt=""><br><img src="../images/java_learm/15116998175776.jpg" alt=""></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;工程化专题（团队大于3个人之后，你需要去考虑团队合作，科学管理）&lt;br&gt;&lt;img src=&quot;../images/java_learm/15116988518629.jpg&quot; alt=&quot;&quot;&gt;
    
    </summary>
    
      <category term="架构师晋级" scheme="http://www.springwork.cn/categories/%E6%9E%B6%E6%9E%84%E5%B8%88%E6%99%8B%E7%BA%A7/"/>
    
      <category term="[object Object]" scheme="http://www.springwork.cn/categories/%E6%9E%B6%E6%9E%84%E5%B8%88%E6%99%8B%E7%BA%A7/object-Object/"/>
    
      <category term="java学习脑图" scheme="http://www.springwork.cn/categories/%E6%9E%B6%E6%9E%84%E5%B8%88%E6%99%8B%E7%BA%A7/object-Object/java%E5%AD%A6%E4%B9%A0%E8%84%91%E5%9B%BE/"/>
    
    
  </entry>
  
  <entry>
    <title>JDK线程池原理</title>
    <link href="http://www.springwork.cn/jdk/JDK%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86.html"/>
    <id>http://www.springwork.cn/jdk/JDK线程池原理.html</id>
    <published>2017-08-29T13:52:12.000Z</published>
    <updated>2017-09-01T14:58:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、线程池概要"><a href="#一、线程池概要" class="headerlink" title="一、线程池概要"></a>一、线程池概要</h2><p>线程池就是一个用来管理线程和复用线程集中工厂，它可以降低系统资源开销、快速启动任务和线程上限控制。</p>
<ol>
<li>初始化线程池规定池核心大小和最大线程数,当execute将任务塞到线程池 </li>
<li>任务插入流程，如果没有超过核心线程数新建worker,如果超过将任务插入到队列，如果队列满了，检查没有超过最大线程数，没有超过再  new  worker ,如果超过执行处理策略，默认是直接报错。</li>
<li>其中任务队列是通过BlockingQueue 的take(没有设置超时时间，worker一直阻塞，直到有任务为止)，poll 可以设置等待超时时间，如果时间范围内没有任务就返回null，worker  如果收到null,就直接释放结束。<a id="more"></a>  
</li>
</ol>
<h2 id="二、设计思路"><a href="#二、设计思路" class="headerlink" title="二、设计思路"></a>二、设计思路</h2><p>1、线程池设计初衷是为了解决线程统一管理，将任务和执行体分离，实现可以对执行体的容量规划和生命周期进行统一管理，实现不用泛滥新建线程。<br>2、容量管理：分为执行体（worker）容量和任务队列容量，策略分别是优先满足核心执行体容量&gt;任务队列容量&gt;最大执行体容器&gt;自我保护pocily。<br>3、生产模式：所有执行体(worker)共享任务列表。<br>4、超时协议（timeout）：执行体在某些策略场景下执行超时释放。<br><img src="../../images/threadPoll.jpg" alt="线程池"></p>
<h2 id="三、源码分析"><a href="#三、源码分析" class="headerlink" title="三、源码分析"></a>三、源码分析</h2><h3 id="1、新建线程池"><a href="#1、新建线程池" class="headerlink" title="1、新建线程池"></a>1、新建线程池</h3><p>新建一个线程池，初始化容量、超时机制、异常自我保护策略做最后兜底</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public ThreadPoolExecutor(int corePoolSize,</div><div class="line">                              int maximumPoolSize,</div><div class="line">                              long keepAliveTime,</div><div class="line">                              TimeUnit unit,</div><div class="line">                              BlockingQueue&lt;Runnable&gt; workQueue,</div><div class="line">                              ThreadFactory threadFactory,</div><div class="line">                              RejectedExecutionHandler handler) &#123;</div><div class="line">                              </div><div class="line">        if (corePoolSize &lt; 0 ||</div><div class="line">            maximumPoolSize &lt;= 0 ||</div><div class="line">            maximumPoolSize &lt; corePoolSize ||</div><div class="line">            keepAliveTime &lt; 0)</div><div class="line">            throw new IllegalArgumentException();</div><div class="line">        if (workQueue == null || threadFactory == null || handler == null)</div><div class="line">            throw new NullPointerException();</div><div class="line">        this.corePoolSize = corePoolSize; // 核心执行体数量</div><div class="line">        this.maximumPoolSize = maximumPoolSize; // 最大执行体数量，只有当任务容量满足不了，才进行扩容</div><div class="line">        this.workQueue = workQueue; // 任务队列</div><div class="line">        this.keepAliveTime = unit.toNanos(keepAliveTime); // 超时时间</div><div class="line">        this.threadFactory = threadFactory; //线程工厂</div><div class="line">        this.handler = handler; // 自我保护策略</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>关于 ThreadFactory 工作原理，可以参考：todo</p>
<h3 id="1、新建任务"><a href="#1、新建任务" class="headerlink" title="1、新建任务"></a>1、新建任务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public void execute(Runnable command) &#123;</div><div class="line">        if (command == null)</div><div class="line">            throw new NullPointerException();</div><div class="line"></div><div class="line">         // 获取当前running 线程数</div><div class="line">        int c = ctl.get();</div><div class="line">        // 1、当执行体数量小于核心线程数，新建执行体</div><div class="line">        if (workerCountOf(c) &lt; corePoolSize) &#123;</div><div class="line">            if (addWorker(command, true))</div><div class="line">                return;</div><div class="line">            c = ctl.get();</div><div class="line">        &#125;</div><div class="line">        //2、线程池running,如果任务队列未满，则将任务插入到队列，如果队列已经满了,则new worker,如果worker 数量大于最大数量时，执行保护策略。               </div><div class="line">        if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</div><div class="line">            int recheck = ctl.get();</div><div class="line">             //todo 如果线程池不在执行状态，而且移除任务，则执行拒绝策略 </div><div class="line">            if (! isRunning(recheck) &amp;&amp; remove(command))</div><div class="line">                reject(command);</div><div class="line">            // 如果worker数量=0，则新建一个空执行体  </div><div class="line">            else if (workerCountOf(recheck) == 0)</div><div class="line">                addWorker(null, false);</div><div class="line">        &#125;</div><div class="line">        //如果队列满，而且没有超过最大执行体数，新建执行体，超过执行体数，则执行拒绝策略</div><div class="line">        else if (!addWorker(command, false))</div><div class="line">            reject(command);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="2、新建worker"><a href="#2、新建worker" class="headerlink" title="2、新建worker"></a>2、新建worker</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line">private boolean addWorker(Runnable firstTask, boolean core) &#123;</div><div class="line">        retry:</div><div class="line">        for (;;) &#123;</div><div class="line">            int c = ctl.get();</div><div class="line">            int rs = runStateOf(c);</div><div class="line"></div><div class="line">            // 线程池状态为下线、停止、清理、终止 直接返回，但是线程池状态为下线、执行体为空、队列有任务可以跳过</div><div class="line">            if (rs &gt;= SHUTDOWN &amp;&amp;</div><div class="line">                ! (rs == SHUTDOWN &amp;&amp;</div><div class="line">                   firstTask == null &amp;&amp;</div><div class="line">                   ! workQueue.isEmpty()))</div><div class="line">                return false;</div><div class="line">            // 如果超过执行体数，直接返回false,其他更新执行体数量，成功提出循环，失败则判断线程池状态有没有变，变了，从头执行，没有变，则一直执行更新执行体数量</div><div class="line">            for (;;) &#123;</div><div class="line">                int wc = workerCountOf(c);</div><div class="line">                if (wc &gt;= CAPACITY ||</div><div class="line">                    wc &gt;= (core ? corePoolSize : maximumPoolSize))</div><div class="line">                    return false;</div><div class="line">                // cas 更新</div><div class="line">                if (compareAndIncrementWorkerCount(c))</div><div class="line">                    break retry;</div><div class="line">                c = ctl.get();  // Re-read ctl</div><div class="line">                // 线程池状态变，则从头执行，否则内部遍历</div><div class="line">                if (runStateOf(c) != rs)</div><div class="line">                    continue retry;</div><div class="line">                // else CAS failed due to workerCount change; retry inner loop</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        boolean workerStarted = false;</div><div class="line">        boolean workerAdded = false;</div><div class="line">        Worker w = null;</div><div class="line">        try &#123;</div><div class="line">            w = new Worker(firstTask);</div><div class="line">            final Thread t = w.thread;</div><div class="line">            if (t != null) &#123;</div><div class="line">                final ReentrantLock mainLock = this.mainLock;</div><div class="line">                mainLock.lock();</div><div class="line">                try &#123;</div><div class="line">                    // Recheck while holding lock.</div><div class="line">                    // Back out on ThreadFactory failure or if</div><div class="line">                    // shut down before lock acquired.</div><div class="line">                    int rs = runStateOf(ctl.get());</div><div class="line"></div><div class="line">                    if (rs &lt; SHUTDOWN ||</div><div class="line">                        (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123;</div><div class="line">                        if (t.isAlive()) // precheck that t is startable</div><div class="line">                            throw new IllegalThreadStateException();</div><div class="line">                        workers.add(w);</div><div class="line">                        int s = workers.size();</div><div class="line">                        if (s &gt; largestPoolSize)</div><div class="line">                            largestPoolSize = s;</div><div class="line">                        workerAdded = true;</div><div class="line">                    &#125;</div><div class="line">                &#125; finally &#123;</div><div class="line">                    mainLock.unlock();</div><div class="line">                &#125;</div><div class="line">                if (workerAdded) &#123;</div><div class="line">                    t.start();</div><div class="line">                    workerStarted = true;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; finally &#123;</div><div class="line">            if (! workerStarted)</div><div class="line">                addWorkerFailed(w);</div><div class="line">        &#125;</div><div class="line">        return workerStarted;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>关于AtomicInteger原理，可以参考：todo<br>关于ReentrantLock原理，可以参考：todo</p>
<blockquote>
<p>break、return、contine的区别备注：for 循环中break 退出for循环，return 直接方法体返回，contine 跳过当前执行流程进入下一次执行。</p>
</blockquote>
<h3 id="3、worker消费任务队列"><a href="#3、worker消费任务队列" class="headerlink" title="3、worker消费任务队列"></a>3、worker消费任务队列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">final void runWorker(Worker w) &#123;</div><div class="line">        Thread wt = Thread.currentThread();</div><div class="line">        Runnable task = w.firstTask;</div><div class="line">        w.firstTask = null;</div><div class="line">        w.unlock(); // allow interrupts</div><div class="line">        boolean completedAbruptly = true;</div><div class="line">        try &#123;</div><div class="line">            //task 阻塞在gettask，如果获取task=null,worker释放，不为null,执行任务</div><div class="line">            while (task != null || (task = getTask()) != null) &#123;</div><div class="line">                w.lock();</div><div class="line">                // If pool is stopping, ensure thread is interrupted;</div><div class="line">                // if not, ensure thread is not interrupted.  This</div><div class="line">                // requires a recheck in second case to deal with</div><div class="line">                // shutdownNow race while clearing interrupt</div><div class="line">                if ((runStateAtLeast(ctl.get(), STOP) ||</div><div class="line">                     (Thread.interrupted() &amp;&amp;</div><div class="line">                      runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</div><div class="line">                    !wt.isInterrupted())</div><div class="line">                    wt.interrupt();</div><div class="line">                try &#123;</div><div class="line">                    beforeExecute(wt, task);</div><div class="line">                    Throwable thrown = null;</div><div class="line">                    try &#123;</div><div class="line">                        task.run();</div><div class="line">                    &#125; catch (RuntimeException x) &#123;</div><div class="line">                        thrown = x; throw x;</div><div class="line">                    &#125; catch (Error x) &#123;</div><div class="line">                        thrown = x; throw x;</div><div class="line">                    &#125; catch (Throwable x) &#123;</div><div class="line">                        thrown = x; throw new Error(x);</div><div class="line">                    &#125; finally &#123;</div><div class="line">                        afterExecute(task, thrown);</div><div class="line">                    &#125;</div><div class="line">                &#125; finally &#123;</div><div class="line">                    task = null;</div><div class="line">                    w.completedTasks++;</div><div class="line">                    w.unlock();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            completedAbruptly = false;</div><div class="line">        &#125; finally &#123;</div><div class="line">            processWorkerExit(w, completedAbruptly);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>while执行任务，通过阻塞在getTask，如果task为null,则释放worker.</p>
<p>AQS 分析 todo</p>
<h3 id="3、task任务队列"><a href="#3、task任务队列" class="headerlink" title="3、task任务队列"></a>3、task任务队列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">private Runnable getTask() &#123;</div><div class="line">        boolean timedOut = false; // Did the last poll() time out?</div><div class="line"></div><div class="line">        for (;;) &#123;</div><div class="line">            int c = ctl.get();</div><div class="line">            int rs = runStateOf(c);</div><div class="line"></div><div class="line">            // 如果线程池关闭或者任务未0，释放worker</div><div class="line">            // 如果线程池任务为关闭，则直接释放</div><div class="line">            if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</div><div class="line">                decrementWorkerCount();</div><div class="line">                return null;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            int wc = workerCountOf(c);</div><div class="line"></div><div class="line">            // Are workers subject to culling?</div><div class="line">            boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</div><div class="line"></div><div class="line">            if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</div><div class="line">                &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) &#123;</div><div class="line">                if (compareAndDecrementWorkerCount(c))</div><div class="line">                    return null;</div><div class="line">                continue;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            try &#123;</div><div class="line">                Runnable r = timed ?</div><div class="line">                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</div><div class="line">                    workQueue.take();</div><div class="line">                if (r != null)</div><div class="line">                    return r;</div><div class="line">                timedOut = true;</div><div class="line">            &#125; catch (InterruptedException retry) &#123;</div><div class="line">                timedOut = false;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>如果任务有设置超时时间，通过queue的poll建立超时返回机制，没有的话直接使用take一直阻塞。<br>关于LinkedBlockingQueue，可以参考：<a href="mweblib://15036544826681" target="_blank" rel="external">LinkedBlockingQueue 原理分析</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、线程池概要&quot;&gt;&lt;a href=&quot;#一、线程池概要&quot; class=&quot;headerlink&quot; title=&quot;一、线程池概要&quot;&gt;&lt;/a&gt;一、线程池概要&lt;/h2&gt;&lt;p&gt;线程池就是一个用来管理线程和复用线程集中工厂，它可以降低系统资源开销、快速启动任务和线程上限控制。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;初始化线程池规定池核心大小和最大线程数,当execute将任务塞到线程池 &lt;/li&gt;
&lt;li&gt;任务插入流程，如果没有超过核心线程数新建worker,如果超过将任务插入到队列，如果队列满了，检查没有超过最大线程数，没有超过再  new  worker ,如果超过执行处理策略，默认是直接报错。&lt;/li&gt;
&lt;li&gt;其中任务队列是通过BlockingQueue 的take(没有设置超时时间，worker一直阻塞，直到有任务为止)，poll 可以设置等待超时时间，如果时间范围内没有任务就返回null，worker  如果收到null,就直接释放结束。
    
    </summary>
    
      <category term="JDK" scheme="http://www.springwork.cn/categories/JDK/"/>
    
      <category term="线程池" scheme="http://www.springwork.cn/categories/JDK/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
    
      <category term="线程池" scheme="http://www.springwork.cn/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>集群流控系统思考</title>
    <link href="http://www.springwork.cn/%E9%9B%86%E7%BE%A4%E6%B5%81%E9%87%8F%E7%B3%BB%E7%BB%9F%E6%80%9D%E8%80%83.html"/>
    <id>http://www.springwork.cn/集群流量系统思考.html</id>
    <published>2017-08-29T13:33:37.000Z</published>
    <updated>2017-09-01T14:57:57.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、业务诉求"><a href="#一、业务诉求" class="headerlink" title="一、业务诉求"></a>一、业务诉求</h3><p> 实现流量统计，当流量达到某一个阀值点，进行阀值处理策略，可以应用于反爬虫、阶段热点等业务场景<br> <a id="more"></a></p>
<h3 id="二、架构"><a href="#二、架构" class="headerlink" title="二、架构"></a>二、架构</h3><p><strong>粗暴架构：</strong><br>将url+时间点为key,放到缓存中，每次请求过来，去check一下有没有达到阀值点。<br>风险：</p>
<ul>
<li>缓存qps会非常大，缓存可能会被击穿。</li>
<li>具有读又有写，业务请求强耦合流控系统缓存，将会形成单点问题。</li>
</ul>
<p><strong>大并发架构：</strong><br>将系统拆分为：流量计数、流控策略、策略同步<br><img src="../images/架构/流控.jpg" alt=""></p>
<ul>
<li><p>流程计数：<br>流量进来，先通过消息异步化，到流量   计数模块，流量计数模块按url+分钟+业务为key,缓存到本地，然后定时刷新到redis。<br>好处：通过消息缓冲避免出现redis请求毛刺，再通过本地缓存避免每次消息消费对redis资源依赖，减少消息堆积风险和redis数据更新压力。</p>
<blockquote>
<p>基本链路：<br>流量-&gt;消息-&gt;本地缓存计数-&gt;分布式缓存</p>
</blockquote>
</li>
<li><p>流控策略：<br>当流程计数触发到阀值，server将其广播到client,client根据自己配置策略，进行拦截、报错等自定义自我处理策略</p>
<blockquote>
<p>server只是负责阀值识别，不做策略处理，将策略处理是否到client,好处：可以解耦防止业务系统对中间件强依赖；还可以实现不同client差异化处理策略</p>
</blockquote>
</li>
<li><p>流程同步:<br>可以通过消息广播或者ZK等等方式</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、业务诉求&quot;&gt;&lt;a href=&quot;#一、业务诉求&quot; class=&quot;headerlink&quot; title=&quot;一、业务诉求&quot;&gt;&lt;/a&gt;一、业务诉求&lt;/h3&gt;&lt;p&gt; 实现流量统计，当流量达到某一个阀值点，进行阀值处理策略，可以应用于反爬虫、阶段热点等业务场景&lt;br&gt;
    
    </summary>
    
      <category term="架构" scheme="http://www.springwork.cn/categories/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="流控" scheme="http://www.springwork.cn/categories/%E6%9E%B6%E6%9E%84/%E6%B5%81%E6%8E%A7/"/>
    
    
      <category term="流控" scheme="http://www.springwork.cn/tags/%E6%B5%81%E6%8E%A7/"/>
    
  </entry>
  
</feed>
